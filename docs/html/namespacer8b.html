<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TorpedoSimulator: r8b Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TorpedoSimulator
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">torpedosimulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacer8b.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">r8b Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The "r8brain-free-src" library namespace.  
<a href="namespacer8b.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_block_convolver.html">CDSPBlockConvolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-block overlap-save convolution processing class.  <a href="classr8b_1_1_c_d_s_p_block_convolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_f_i_r_filter.html">CDSPFIRFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation and storage class for FIR filters.  <a href="classr8b_1_1_c_d_s_p_f_i_r_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_f_i_r_filter_cache.html">CDSPFIRFilterCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIR filter cache class.  <a href="classr8b_1_1_c_d_s_p_f_i_r_filter_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_frac_delay_filter_bank.html">CDSPFracDelayFilterBank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sinc function-based fractional delay filter bank class.  <a href="classr8b_1_1_c_d_s_p_frac_delay_filter_bank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_frac_delay_filter_bank_cache.html">CDSPFracDelayFilterBankCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fractional delay filter cache class.  <a href="classr8b_1_1_c_d_s_p_frac_delay_filter_bank_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_frac_interpolator.html">CDSPFracInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fractional delay filter bank-based interpolator class.  <a href="classr8b_1_1_c_d_s_p_frac_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_h_b_downsampler.html">CDSPHBDownsampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half-band downsampler class.  <a href="classr8b_1_1_c_d_s_p_h_b_downsampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_h_b_upsampler.html">CDSPHBUpsampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half-band upsampling class.  <a href="classr8b_1_1_c_d_s_p_h_b_upsampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_processor.html">CDSPProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base virtual class for DSP processing algorithms.  <a href="classr8b_1_1_c_d_s_p_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_real_f_f_t.html">CDSPRealFFT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-valued FFT transform class.  <a href="classr8b_1_1_c_d_s_p_real_f_f_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_real_f_f_t_keeper.html">CDSPRealFFTKeeper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "keeper" class for real-valued FFT transform objects.  <a href="classr8b_1_1_c_d_s_p_real_f_f_t_keeper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_resampler.html">CDSPResampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master sample rate converter (resampler) class.  <a href="classr8b_1_1_c_d_s_p_resampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_resampler16.html">CDSPResampler16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resampler class for 16-bit resampling.  <a href="classr8b_1_1_c_d_s_p_resampler16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_resampler16_i_r.html">CDSPResampler16IR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resampler class for 16-bit impulse response resampling.  <a href="classr8b_1_1_c_d_s_p_resampler16_i_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_resampler24.html">CDSPResampler24</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resampler class for 24-bit resampling.  <a href="classr8b_1_1_c_d_s_p_resampler24.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_d_s_p_sinc_filter_gen.html">CDSPSincFilterGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sinc function-based FIR filter generator class.  <a href="classr8b_1_1_c_d_s_p_sinc_filter_gen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1ooura__fft.html">ooura_fft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class around Takuya OOURA's FFT functions.  <a href="classr8b_1_1ooura__fft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_std_class_allocator.html">CStdClassAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default base class for objects created on heap.  <a href="classr8b_1_1_c_std_class_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_std_mem_allocator.html">CStdMemAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default base class for objects that allocate blocks of memory.  <a href="classr8b_1_1_c_std_mem_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_fixed_buffer.html">CFixedBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated memory buffer class for element buffers of fixed capacity.  <a href="classr8b_1_1_c_fixed_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_ptr_keeper.html">CPtrKeeper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-to-object "keeper" class with automatic deletion.  <a href="classr8b_1_1_c_ptr_keeper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_sync_object.html">CSyncObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded synchronization object class.  <a href="classr8b_1_1_c_sync_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_sync_keeper.html">CSyncKeeper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "keeper" class for CSyncObject-based synchronization.  <a href="classr8b_1_1_c_sync_keeper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classr8b_1_1_c_sine_gen.html">CSineGen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine signal generator class.  <a href="classr8b_1_1_c_sine_gen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4e4e7c6892152662eb6c76c95573c66d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a4e4e7c6892152662eb6c76c95573c66d">EDSPFilterPhaseResponse</a> { <a class="el" href="namespacer8b.html#a4e4e7c6892152662eb6c76c95573c66da9892a60c4794d3ae4419023479bd61d4">fprLinearPhase</a> = 0
, <a class="el" href="namespacer8b.html#a4e4e7c6892152662eb6c76c95573c66da3909b0b8dcf6e22e016eebc12aad07ec">fprMinPhase</a>
 }</td></tr>
<tr class="separator:a4e4e7c6892152662eb6c76c95573c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7e5621bdbbb4494753c443906762a35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#ab7e5621bdbbb4494753c443906762a35">findGCD</a> (double l, double s, double &amp;GCD)</td></tr>
<tr class="separator:ab7e5621bdbbb4494753c443906762a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e24a33aa9982eda41fc95265a41c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a028e24a33aa9982eda41fc95265a41c8">getWholeStepping</a> (const double SSampleRate, const double DSampleRate, int &amp;ResInStep, int &amp;ResOutStep)</td></tr>
<tr class="separator:a028e24a33aa9982eda41fc95265a41c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e49987499a83d47156b52bce999812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#af0e49987499a83d47156b52bce999812">calcMinPhaseTransform</a> (double *const Kernel, const int KernelLen, const int LenMult=2, const bool DoFinalMul=true, double *const DCGroupDelay=NULL)</td></tr>
<tr class="separator:af0e49987499a83d47156b52bce999812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbfeab5ac4bbd8cd0482eee01610d51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a8dbfeab5ac4bbd8cd0482eee01610d51">getBitOccupancy</a> (const int v)</td></tr>
<tr class="separator:a8dbfeab5ac4bbd8cd0482eee01610d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337c7aaf705266f03efbc9f71fe035a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a337c7aaf705266f03efbc9f71fe035a3">calcFIRFilterResponse</a> (const double *flt, int fltlen, const double th, double &amp;re0, double &amp;im0, const int fltlat=0)</td></tr>
<tr class="separator:a337c7aaf705266f03efbc9f71fe035a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab9d5d341b8ade14fa89623c8140cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a0ab9d5d341b8ade14fa89623c8140cdc">calcFIRFilterResponseAndGroupDelay</a> (const double *const flt, const int fltlen, const double th, double &amp;re, double &amp;im, double &amp;gd)</td></tr>
<tr class="separator:a0ab9d5d341b8ade14fa89623c8140cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b55e9148e615282f2a6471873adf59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#af7b55e9148e615282f2a6471873adf59">normalizeFIRFilter</a> (double *const p, const int l, const double DCGain, const int pstep=1)</td></tr>
<tr class="separator:af7b55e9148e615282f2a6471873adf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f548990775016a01f4b4c5f5b2828f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a44f548990775016a01f4b4c5f5b2828f">calcSpline3p8Coeffs</a> (double *c, const double xm3, const double xm2, const double xm1, const double x0, const double x1, const double x2, const double x3, const double x4)</td></tr>
<tr class="separator:a44f548990775016a01f4b4c5f5b2828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2f779647fcb3f6f4b2e5e770ae0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#ac1c2f779647fcb3f6f4b2e5e770ae0bc">calcSpline2p8Coeffs</a> (double *c, const double xm3, const double xm2, const double xm1, const double x0, const double x1, const double x2, const double x3, const double x4)</td></tr>
<tr class="separator:ac1c2f779647fcb3f6f4b2e5e770ae0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa073629d8e5eb49b09d12158002ca7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#aa073629d8e5eb49b09d12158002ca7d8">calcInterpCoeffs3p4</a> (double *const c, const double *const y)</td></tr>
<tr class="separator:aa073629d8e5eb49b09d12158002ca7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55df19dd2abfea512b0078a9ee28794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#ab55df19dd2abfea512b0078a9ee28794">calcInterpCoeffs3p6</a> (double *const c, const double *const y)</td></tr>
<tr class="separator:ab55df19dd2abfea512b0078a9ee28794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31edfcb7babe9b0a906fe60f6f54b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a5a31edfcb7babe9b0a906fe60f6f54b3">calcInterpCoeffs3p8</a> (double *const c, const double *const y)</td></tr>
<tr class="separator:a5a31edfcb7babe9b0a906fe60f6f54b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee8754a552f808b4e1e97582aba1f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#adee8754a552f808b4e1e97582aba1f74">calcInterpCoeffs2p8</a> (double *const c, const double *const y)</td></tr>
<tr class="separator:adee8754a552f808b4e1e97582aba1f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829f1c5aab656a4b80caccc95c8f2d8f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a829f1c5aab656a4b80caccc95c8f2d8f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a829f1c5aab656a4b80caccc95c8f2d8f">min</a> (const T &amp;v1, const T &amp;v2)</td></tr>
<tr class="separator:a829f1c5aab656a4b80caccc95c8f2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6238a758495bb8ab227046476011004"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa6238a758495bb8ab227046476011004"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacer8b.html#aa6238a758495bb8ab227046476011004">max</a> (const T &amp;v1, const T &amp;v2)</td></tr>
<tr class="separator:aa6238a758495bb8ab227046476011004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c78f2233d085f244da8d736c4c92d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#aa6c78f2233d085f244da8d736c4c92d6">clampr</a> (const double Value, const double minv, const double maxv)</td></tr>
<tr class="separator:aa6c78f2233d085f244da8d736c4c92d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc80522c1b10045a4ffdf8f3f946931f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#afc80522c1b10045a4ffdf8f3f946931f">sqr</a> (const double x)</td></tr>
<tr class="separator:afc80522c1b10045a4ffdf8f3f946931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4e0c3ac8f23985426104e3bb794a4a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#aaa4e0c3ac8f23985426104e3bb794a4a">pows</a> (const double v, const double p)</td></tr>
<tr class="separator:aaa4e0c3ac8f23985426104e3bb794a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae091ffa11b8950ad9d17eea77cc2fed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#aae091ffa11b8950ad9d17eea77cc2fed">gauss</a> (const double v)</td></tr>
<tr class="separator:aae091ffa11b8950ad9d17eea77cc2fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad9a5df441f28843f451e35a73d68a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a9ad9a5df441f28843f451e35a73d68a2">asinh</a> (const double v)</td></tr>
<tr class="separator:a9ad9a5df441f28843f451e35a73d68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d8068169a0379d922ec49e9d107587"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#ac4d8068169a0379d922ec49e9d107587">besselI0</a> (const double x)</td></tr>
<tr class="separator:ac4d8068169a0379d922ec49e9d107587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18634f1b79c2b8437fdfe447e0c6abb3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a18634f1b79c2b8437fdfe447e0c6abb3">convertResponseToLog</a> (const double re, const double im)</td></tr>
<tr class="separator:a18634f1b79c2b8437fdfe447e0c6abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac525c403d1a90e0f762c6acd6b828f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#ac525c403d1a90e0f762c6acd6b828f9b">updateScanStep</a> (double &amp;step, const double curg, double &amp;prevg_log, const double prec, const double maxstep, const double minstep=1e-11)</td></tr>
<tr class="separator:ac525c403d1a90e0f762c6acd6b828f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcee0747c097a161b2eb16da2332bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#acbcee0747c097a161b2eb16da2332bef">findFIRFilterResponseMinLtoR</a> (const double *const flt, const int fltlen, double &amp;ming, double &amp;minth, const double thend)</td></tr>
<tr class="separator:acbcee0747c097a161b2eb16da2332bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a41850cc3bcbd12169551c2b4f9a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a04a41850cc3bcbd12169551c2b4f9a54">findFIRFilterResponseMaxLtoR</a> (const double *const flt, const int fltlen, double &amp;maxg, double &amp;maxth, const double thend)</td></tr>
<tr class="separator:a04a41850cc3bcbd12169551c2b4f9a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b38dfb250152aba1e670ec744807a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacer8b.html#a429b38dfb250152aba1e670ec744807a">findFIRFilterResponseLevelRtoL</a> (const double *const flt, const int fltlen, const double maxg, double &amp;th, const double thend)</td></tr>
<tr class="separator:a429b38dfb250152aba1e670ec744807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The "r8brain-free-src" library namespace. </p>
<p>The "r8brain-free-src" sample rate converter library namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4e4e7c6892152662eb6c76c95573c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4e7c6892152662eb6c76c95573c66d">&#9670;&nbsp;</a></span>EDSPFilterPhaseResponse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacer8b.html#a4e4e7c6892152662eb6c76c95573c66d">r8b::EDSPFilterPhaseResponse</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of filter's phase responses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e4e7c6892152662eb6c76c95573c66da9892a60c4794d3ae4419023479bd61d4"></a>fprLinearPhase&#160;</td><td class="fielddoc"><p>Linear-phase response. Features a linear-phase high-latency response, with the latency expressed as integer value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4e4e7c6892152662eb6c76c95573c66da3909b0b8dcf6e22e016eebc12aad07ec"></a>fprMinPhase&#160;</td><td class="fielddoc"><p>Minimum-phase response. Features a minimal latency response, but the response's phase is non-linear. The latency is usually expressed as non-integer value, and usually is small, but is never equal to zero. The minimum-phase filter is transformed from the linear-phase filter. The transformation has precision limits which may skew both the -3 dB point and attenuation of the filter being transformed: as it was measured, the skew happens purely at random, and in most cases it is within tolerable range. In a small (1%) random subset of cases the skew is bigger and cannot be predicted. Minimum-phase transform requires 64-bit floating point FFT precision, results with 32-bit float FFT are far from optimal. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9ad9a5df441f28843f451e35a73d68a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad9a5df441f28843f451e35a73d68a2">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::asinh </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated inverse hyperbolic sine of the input value. </dd></dl>

</div>
</div>
<a id="ac4d8068169a0379d922ec49e9d107587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d8068169a0379d922ec49e9d107587">&#9670;&nbsp;</a></span>besselI0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::besselI0 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated zero-th order modified Bessel function of the first kind of the input value. Approximate value. </dd></dl>

</div>
</div>
<a id="a337c7aaf705266f03efbc9f71fe035a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337c7aaf705266f03efbc9f71fe035a3">&#9670;&nbsp;</a></span>calcFIRFilterResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcFIRFilterResponse </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>flt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>re0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>im0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fltlat</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates frequency response of the specified FIR filter at the specified circular frequency. Phase can be calculated as atan2( im, re ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">flt</td><td>FIR filter's coefficients. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlen</td><td>Number of coefficients (taps) in the filter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">th</td><td>Circular frequency [0; pi]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">re0</td><td>Resulting real part of the complex frequency response. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">im0</td><td>Resulting imaginary part of the complex frequency response. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlat</td><td>Filter's latency in samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ab9d5d341b8ade14fa89623c8140cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab9d5d341b8ade14fa89623c8140cdc">&#9670;&nbsp;</a></span>calcFIRFilterResponseAndGroupDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcFIRFilterResponseAndGroupDelay </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>flt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>gd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates frequency response and group delay of the specified FIR filter at the specified circular frequency. The group delay is calculated by evaluating the filter's response at close side-band frequencies of "th".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">flt</td><td>FIR filter's coefficients. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlen</td><td>Number of coefficients (taps) in the filter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">th</td><td>Circular frequency [0; pi]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">re</td><td>Resulting real part of the complex frequency response. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">im</td><td>Resulting imaginary part of the complex frequency response. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gd</td><td>Resulting group delay at the specified frequency, in samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee8754a552f808b4e1e97582aba1f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee8754a552f808b4e1e97582aba1f74">&#9670;&nbsp;</a></span>calcInterpCoeffs2p8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcInterpCoeffs2p8 </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 3rd order segment interpolation polynomial on the equidistant lattice, using 8 points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Equidistant point values. Value at offset 3 corresponds to x=0 point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa073629d8e5eb49b09d12158002ca7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa073629d8e5eb49b09d12158002ca7d8">&#9670;&nbsp;</a></span>calcInterpCoeffs3p4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcInterpCoeffs3p4 </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 3rd order segment interpolation polynomial on the equidistant lattice, using 4 points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Equidistant point values. Value at offset 1 corresponds to x=0 point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55df19dd2abfea512b0078a9ee28794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55df19dd2abfea512b0078a9ee28794">&#9670;&nbsp;</a></span>calcInterpCoeffs3p6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcInterpCoeffs3p6 </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 3rd order segment interpolation polynomial on the equidistant lattice, using 6 points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Equidistant point values. Value at offset 2 corresponds to x=0 point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a31edfcb7babe9b0a906fe60f6f54b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a31edfcb7babe9b0a906fe60f6f54b3">&#9670;&nbsp;</a></span>calcInterpCoeffs3p8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcInterpCoeffs3p8 </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 3rd order segment interpolation polynomial on the equidistant lattice, using 8 points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Equidistant point values. Value at offset 3 corresponds to x=0 point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0e49987499a83d47156b52bce999812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e49987499a83d47156b52bce999812">&#9670;&nbsp;</a></span>calcMinPhaseTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcMinPhaseTransform </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>KernelLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>LenMult</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>DoFinalMul</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>DCGroupDelay</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates the minimum-phase transform of the filter kernel, using a discrete Hilbert transform in cepstrum domain.</p>
<p>For more details, see part III.B of <a href="http://www.hpl.hp.com/personal/Niranjan_Damera-Venkata/files/ComplexMinPhase.pdf">http://www.hpl.hp.com/personal/Niranjan_Damera-Venkata/files/ComplexMinPhase.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Kernel</td><td>Filter kernel buffer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">KernelLen</td><td>Filter kernel's length, in samples. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LenMult</td><td>Kernel length multiplier. Used as a coefficient of the "oversampling" in the frequency domain. Such oversampling is needed to improve the precision of the minimum-phase transform. If the filter's attenuation is high, this multiplier should be increased or otherwise the required attenuation will not be reached due to "smoothing" effect of this transform. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">DoFinalMul</td><td>"True" if the final multiplication after transform should be performed or not. Such multiplication returns the gain of the signal to its original value. This parameter can be set to "false" if normalization of the resulting filter kernel is planned to be used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DCGroupDelay</td><td>If not NULL, this variable receives group delay at DC offset, in samples (can be a non-integer value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c2f779647fcb3f6f4b2e5e770ae0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2f779647fcb3f6f4b2e5e770ae0bc">&#9670;&nbsp;</a></span>calcSpline2p8Coeffs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcSpline2p8Coeffs </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 2rd order spline (polynomial) on the equidistant lattice, using 8 points. This function is based on the calcSpline3Coeffs8() function, but without the 3rd order coefficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 3. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm3</td><td>Point at x-3 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm2</td><td>Point at x-2 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm1</td><td>Point at x-1 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>Point at x position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Point at x+1 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x2</td><td>Point at x+2 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x3</td><td>Point at x+3 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x4</td><td>Point at x+4 position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44f548990775016a01f4b4c5f5b2828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f548990775016a01f4b4c5f5b2828f">&#9670;&nbsp;</a></span>calcSpline3p8Coeffs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::calcSpline3p8Coeffs </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function calculates coefficients used to calculate 3rd order spline (polynomial) on the equidistant lattice, using 8 points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output coefficients buffer, length = 4. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm3</td><td>Point at x-3 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm2</td><td>Point at x-2 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xm1</td><td>Point at x-1 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x0</td><td>Point at x position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x1</td><td>Point at x+1 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x2</td><td>Point at x+2 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x3</td><td>Point at x+3 position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x4</td><td>Point at x+4 position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6c78f2233d085f244da8d736c4c92d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c78f2233d085f244da8d736c4c92d6">&#9670;&nbsp;</a></span>clampr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::clampr </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>minv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function "clamps" (clips) the specified value so that it is not lesser than "minv", and not greater than "maxv".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to clamp. </td></tr>
    <tr><td class="paramname">minv</td><td>Minimal allowed value. </td></tr>
    <tr><td class="paramname">maxv</td><td>Maximal allowed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"Clamped" value. </dd></dl>

</div>
</div>
<a id="a18634f1b79c2b8437fdfe447e0c6abb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18634f1b79c2b8437fdfe447e0c6abb3">&#9670;&nbsp;</a></span>convertResponseToLog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::convertResponseToLog </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>Real part of the frequency response. </td></tr>
    <tr><td class="paramname">im</td><td>Imaginary part of the frequency response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A magnitude response value converted from the linear scale to the logarithmic scale. </dd></dl>

</div>
</div>
<a id="a429b38dfb250152aba1e670ec744807a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429b38dfb250152aba1e670ec744807a">&#9670;&nbsp;</a></span>findFIRFilterResponseLevelRtoL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::findFIRFilterResponseLevelRtoL </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>flt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>thend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function locates normalized frequency at which the specified maximum filter gain is reached. The scanning is performed from higher (right) to lower (left) frequencies, scanning stops when the required gain value was crossed. Function uses an extremely efficient binary search and thus expects that the magnitude response has the "main lobe" form produced by windowing, with a minimal pass-band ripple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">flt</td><td>Filter response. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlen</td><td>Filter response's length in samples (taps). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxg</td><td>Maximal gain (squared). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">th</td><td>The current normalized frequency. On function's return will point to the normalized frequency where "maxg" is reached. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thend</td><td>The leftmost frequency to scan, inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a41850cc3bcbd12169551c2b4f9a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a41850cc3bcbd12169551c2b4f9a54">&#9670;&nbsp;</a></span>findFIRFilterResponseMaxLtoR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::findFIRFilterResponseMaxLtoR </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>flt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>thend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function locates normalized frequency at which the maximal filter gain is reached. The scanning is performed from lower (left) to higher (right) frequencies, the whole range is scanned.</p>
<p>Note: this function may "stall" in very rare cases if the magnitude response happens to be "saw-tooth" like, requiring a very small stepping to be used. If this happens, it may take dozens of seconds to complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">flt</td><td>Filter response. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlen</td><td>Filter response's length in samples (taps). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxg</td><td>The current maximal gain (squared). On function's return will contain the maximal gain value (squared). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxth</td><td>The normalized frequency where the maximal gain is currently at. On function's return will point to the normalized frequency where the maximum was reached. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thend</td><td>The ending frequency, inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbcee0747c097a161b2eb16da2332bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcee0747c097a161b2eb16da2332bef">&#9670;&nbsp;</a></span>findFIRFilterResponseMinLtoR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::findFIRFilterResponseMinLtoR </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>flt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fltlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>thend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function locates normalized frequency at which the minimum filter gain is reached. The scanning is performed from lower (left) to higher (right) frequencies, the whole range is scanned.</p>
<p>Function expects that the magnitude response is always reducing from lower to high frequencies, starting at "minth".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">flt</td><td>Filter response. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fltlen</td><td>Filter response's length in samples (taps). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ming</td><td>The current minimal gain (squared). On function's return will contain the minimal gain value found (squared). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minth</td><td>The normalized frequency where the minimal gain is currently at. On function's return will point to the normalized frequency where the new minimum was found. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thend</td><td>The ending frequency, inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7e5621bdbbb4494753c443906762a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e5621bdbbb4494753c443906762a35">&#9670;&nbsp;</a></span>findGCD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool r8b::findGCD </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>GCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">l</td><td>Number 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>Number 2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GCD</td><td>Resulting GCD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"True" if the greatest common denominator of 2 numbers was found. </dd></dl>

</div>
</div>
<a id="aae091ffa11b8950ad9d17eea77cc2fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae091ffa11b8950ad9d17eea77cc2fed">&#9670;&nbsp;</a></span>gauss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::gauss </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated single-argument Gaussian function of the input value. </dd></dl>

</div>
</div>
<a id="a8dbfeab5ac4bbd8cd0482eee01610d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbfeab5ac4bbd8cd0482eee01610d51">&#9670;&nbsp;</a></span>getBitOccupancy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int r8b::getBitOccupancy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated bit occupancy of the specified input value. Bit occupancy means how many significant lower bits are necessary to store a specified value. Function treats the input value as unsigned. </dd></dl>

</div>
</div>
<a id="a028e24a33aa9982eda41fc95265a41c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028e24a33aa9982eda41fc95265a41c8">&#9670;&nbsp;</a></span>getWholeStepping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool r8b::getWholeStepping </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>SSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>DSampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ResInStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ResOutStep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function evaluates source and destination sample rate ratio and returns the required input and output stepping. Function returns "false" if *this class cannot be used to perform interpolation using these sample rates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">SSampleRate</td><td>Source sample rate. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">DSampleRate</td><td>Destination sample rate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResInStep</td><td>Resulting input step. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ResOutStep</td><td>Resulting output step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"True" if stepping was acquired. </dd></dl>

</div>
</div>
<a id="aa6238a758495bb8ab227046476011004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6238a758495bb8ab227046476011004">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T r8b::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Value 1. </td></tr>
    <tr><td class="paramname">v2</td><td>Value 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum of 2 values. </dd></dl>

</div>
</div>
<a id="a829f1c5aab656a4b80caccc95c8f2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829f1c5aab656a4b80caccc95c8f2d8f">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T r8b::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Value 1. </td></tr>
    <tr><td class="paramname">v2</td><td>Value 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum of 2 values. </dd></dl>

</div>
</div>
<a id="af7b55e9148e615282f2a6471873adf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b55e9148e615282f2a6471873adf59">&#9670;&nbsp;</a></span>normalizeFIRFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::normalizeFIRFilter </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>DCGain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pstep</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function normalizes FIR filter so that its frequency response at DC is equal to DCGain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>Filter coefficients. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">l</td><td>Filter length. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">DCGain</td><td>Filter's gain at DC (linear, non-decibel value). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pstep</td><td>"p" array step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa4e0c3ac8f23985426104e3bb794a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4e0c3ac8f23985426104e3bb794a4a">&#9670;&nbsp;</a></span>pows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::pows </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input value. </td></tr>
    <tr><td class="paramname">p</td><td>Power factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="class_eigen_1_1_array_base.html#ab6dc101d82e8228a19a8840e3a29c1c9">pow()</a> function's value with input value's sign check. </dd></dl>

</div>
</div>
<a id="afc80522c1b10045a4ffdf8f3f946931f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc80522c1b10045a4ffdf8f3f946931f">&#9670;&nbsp;</a></span>sqr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double r8b::sqr </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared value of the argument. </dd></dl>

</div>
</div>
<a id="ac525c403d1a90e0f762c6acd6b828f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac525c403d1a90e0f762c6acd6b828f9b">&#9670;&nbsp;</a></span>updateScanStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void r8b::updateScanStep </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>curg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>prevg_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>minstep</em> = <code>1e-11</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An utility function that performs frequency response scanning step update based on the current magnitude response's slope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">step</td><td>The current scanning step. Will be updated on function's return. Must be a positive value. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">curg</td><td>Squared magnitude response at the current frequency point. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prevg_log</td><td>Previous magnitude response, log scale. Will be updated on function's return. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prec</td><td>Precision multiplier, affects the size of the step. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxstep</td><td>The maximal allowed step. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">minstep</td><td>The minimal allowed step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacer8b.html">r8b</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
